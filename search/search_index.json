{
    "docs": [
        {
            "location": "/", 
            "text": "Writing a Maya Python C++ Extension\n\n\nAbout\n\n\nThis is a tutorial on how to expose bindings from your C++ code to Python by\nmeans of writing a Python C++ extension. Unlike standard Python C/C++\nextensions, however, I will elaborate on specific steps to take when writing\nbindings that take advantage of the Maya libraries, along with how the extension\nwill work within the Maya Python interpreter.\n\n\nAll the source code for this example node is available\n\nhere\n.\n\n\nWhy should I care?\n\n\nTo be honest, I actually have started to become less reliant on Python as I\ncontinue to write more and more code, even in Maya, now that I can \nhotload\nmy C++ code\n. However,\nthere are some very good reasons why we might still want to write Python\nbindings for our C++ code:\n\n\n\n\n\n\nLegacy code: the reality is that there is a lot of code out there that is\n  already written in Python. Depending on the project, it might not be worth the\n  effort to re-write the entire project in C++ just for the sake of using a couple\n  of utility functions. However, re-writing C++ functions from scratch back to\n  Python is also a pain, not to mention that we'd take a \nmuch\n larger\n  performance hit than going the route of a Python C++ extension due to the\n  larger amount of memory that would need to be marshaled between the two\n  layers, along with the levels of indirection.\n\n\n\n\n\n\nEase of utilities: while hot-reloadable code is nice, the fact remains that\n  sometimes, it is easier to be able to call specific utility functions from\n  both Python and C++ for the sake of inspecting scenes. Writing template\n  \nMPxCommand\n boilerplate gets incredibly annoying after a while, along with\n  making it more difficult to actually integrate with a Python codebase.\n  (i.e. returning Python \ndict\n or other data types is not possible directly\n  from a traditional Maya command.)\n\n\n\n\n\n\nExtending existing bindings: the reason I even bothered to write this tutorial\n  in the first place is because there's been a lot of grumbling from both at\n  work and outside of work from fellow TDs alike about the state of the Python\n  OpenMaya bindings. My primary goal here is to show that it's actually fairly\n  trivial to write your own bindings if needed.\n\n\n\n\n\n\nWhy not use a wrapper for this?\n\n\nWhen it comes to generating Python bindings for a C/C++ API, there are a\nplethora of tools out there. \n\nBoost.Python\n,\n\nSWIG\n and more recently, \npybind11\n\nare all examples of wrappers that can help to automate the process of having to\nwrite the bindings by hand. As a matter of fact, this is how the OM1 bindings\nwere generated in the first place (using SWIG). Ideally, this allows the\nprogrammer to focus on the implementation on the C/C++ side without worrying \nabout the details involved with translating the code to Python.\n\n\nAt least, that's the theory. As ever, in practice, everything comes down to a\nsingle principle: \nyour job is to work with memory, not write code.\n If you\ndon't know what you're doing with the memory, you're guaranteed to be setting\nyourself (or others) up for failure. In this case, it means:\n\n\n\n\n\n\nHarder-to-debug abstraction layers whenever the bindings don't work as you\n  expect\n. Writing Python bindings is already a level of abstraction that we're\n  accepting here as a necessary cost; the last thing needed is to add \neven\n  more\n cruft on top of that. \n\n\n\n\n\n\nAbsolute control over the memory and how it's managed\n. Rather than code all\n  sorts of machinery in order to perform simple tasks like cleaning up\n  allocations at module destruction time, or wasting time with \nunique_ptr\n\n  and \nshared_ptr\n shennanigans, I find everything is much simpler when just\n  writing the bindings by hand.\n\n\n\n\n\n\npybind11, at least, does not account for the GIL by default unless you make\n  specific wrapper calls (e.g. \ncall_go\n using the \ncall_guard\npolicy). \n  Personally, after giving it a go, I see zero benefit to using it over writing \n  the bindings manually. Every framework has its own shennigans to work with\n  when using them, and I haven't really seen one that I considered worth the\n  cost of working with.\n\n\n\n\n\n\nTo that point, \nnot every project can afford to use a C++11-compliant\n  compiler\n. (Remember, as recently as Maya 2016, the official compiler version\n  was not even C++11 capable)!\n\n\n\n\n\n\nThe \nhistorical results speak for themselves\n: The Maya OM1 bindings, which were\n  generated via SWIG, are far slower than the hand-written bindings in OM2\n  (which are also incidentally far easier to use and don't require the use of\n  other wrapper classes such as \nMScriptUtil\n to handle converting between\n  pointer and POD types). If you're going to eat of the cost of making bindings\n  between a scripting language and a compiled one, you might as well try to\n  minimize the overhead in the process. At scale, automatically-generated\n  bindings just don't work.\n\n\n\n\n\n\n\n\nTip\n\n\nI encourage you to try the alternatives stated and decide for yourself which\napproach is easier at scale and works for your particular use case. Here,\nhowever, I will focus only on hand-writing the bindings and not on any\nunnecessary wrappers since I am focusing on simple examples.\n\n\n\n\nHow is this going to work?\n\n\nWe're going to eschew the official Python\n\ndistutils\n for\nthis, and compile everything on our own. Before you start shouting \"That's\nun-Pythonic!\" from the top of your horse, bear with it: there are fairly good\nreasons for this, which I'll explain later. \n\n\nWe'll be making two types of Maya Python C++ Extensions: the first will be a\ntraditional Python C extension that makes use of the Maya libraries; the second,\nhowever, will be an actual Maya plugin that exposes the Python bindings\nautomatically once it's loaded in Maya. The nice thing about the second approach\nis that if you want to expose your bindings from a Maya plugin, you can do so\njust by loading the plugin itself without having add the \n.pyd/.so\n file onto\nthe \nPYTHONPATH\n. However, this approach also comes with its own cons, which\nI will discuss during the implementation phase.\n\n\nRequirements\n\n\nThis tutorial will come from a \nWindows-first approach\n. Whenever platform-specific\ninformation is appropriate, it will appear in the following form:\n\n\n\n\nCrossing the platforms\n\n\nPlatform-specific information goes here.\n\n\n\n\nWhat you will need\n\n\n\n\n\n\nMaya 2018 or higher\n. \n\n\n\n\n\n\nPython 2.7.xx (Python 3.x series is \nnot\n a substitute!)\n.\n\n\n\n\n\n\nA \nC/C++ development environment\n set up and ready to go. (If you want to see\n  what my Emacs setup looks like, it's\n  available \nhere\n.)\n\n\n\n\n\n\nOn Windows, you will need the corresponding \nVisual Studio\n version that\n  your version of Maya was compiled with. For Maya 2018, this is \nVisual Studio\n  2015\n. \n\n\n\n\n\n\n\n\nCrossing the platforms\n\n\nOn Linux, you will need GCC 4.8.2 against the Linux kernel in CentOS 6.5.\nOn OSX, you will need Xcode 7.3.1 against the 10.11 SDK.\n\n\n\n\n\n\nSpare time and an open mind.\n\n\n\n\nWhat you should know\n\n\n\n\n\n\nBasic knowledge of C/C++\n. I will focus on including only the code that is\n  important; I expect you to be able to understand how to fill in the rest as\n  needed. At the very least, you should be able to compile a Maya plug-in and\n  run it using whatever toolchain you're familar with.\n\n\n\n\n\n\nBasic knowledge of how Maya plugins work and how to write/build them\n. \n  The repository has sample build scripts designed to work on Windows and Linux.\n\n\n\n\n\n\nBasic knowledge of Python\n. Obviously, you'll need to know basic Python\n  syntax and the various data types available, since we're going to be\n  marshaling them between them and C++.\n\n\n\n\n\n\nIn the next section, we'll go over a high-level overview of how a Python C/C++\nextension works.", 
            "title": "About"
        }, 
        {
            "location": "/#writing-a-maya-python-c-extension", 
            "text": "", 
            "title": "Writing a Maya Python C++ Extension"
        }, 
        {
            "location": "/#about", 
            "text": "This is a tutorial on how to expose bindings from your C++ code to Python by\nmeans of writing a Python C++ extension. Unlike standard Python C/C++\nextensions, however, I will elaborate on specific steps to take when writing\nbindings that take advantage of the Maya libraries, along with how the extension\nwill work within the Maya Python interpreter.  All the source code for this example node is available here .", 
            "title": "About"
        }, 
        {
            "location": "/#why-should-i-care", 
            "text": "To be honest, I actually have started to become less reliant on Python as I\ncontinue to write more and more code, even in Maya, now that I can  hotload\nmy C++ code . However,\nthere are some very good reasons why we might still want to write Python\nbindings for our C++ code:    Legacy code: the reality is that there is a lot of code out there that is\n  already written in Python. Depending on the project, it might not be worth the\n  effort to re-write the entire project in C++ just for the sake of using a couple\n  of utility functions. However, re-writing C++ functions from scratch back to\n  Python is also a pain, not to mention that we'd take a  much  larger\n  performance hit than going the route of a Python C++ extension due to the\n  larger amount of memory that would need to be marshaled between the two\n  layers, along with the levels of indirection.    Ease of utilities: while hot-reloadable code is nice, the fact remains that\n  sometimes, it is easier to be able to call specific utility functions from\n  both Python and C++ for the sake of inspecting scenes. Writing template\n   MPxCommand  boilerplate gets incredibly annoying after a while, along with\n  making it more difficult to actually integrate with a Python codebase.\n  (i.e. returning Python  dict  or other data types is not possible directly\n  from a traditional Maya command.)    Extending existing bindings: the reason I even bothered to write this tutorial\n  in the first place is because there's been a lot of grumbling from both at\n  work and outside of work from fellow TDs alike about the state of the Python\n  OpenMaya bindings. My primary goal here is to show that it's actually fairly\n  trivial to write your own bindings if needed.", 
            "title": "Why should I care?"
        }, 
        {
            "location": "/#why-not-use-a-wrapper-for-this", 
            "text": "When it comes to generating Python bindings for a C/C++ API, there are a\nplethora of tools out there.  Boost.Python , SWIG  and more recently,  pybind11 \nare all examples of wrappers that can help to automate the process of having to\nwrite the bindings by hand. As a matter of fact, this is how the OM1 bindings\nwere generated in the first place (using SWIG). Ideally, this allows the\nprogrammer to focus on the implementation on the C/C++ side without worrying \nabout the details involved with translating the code to Python.  At least, that's the theory. As ever, in practice, everything comes down to a\nsingle principle:  your job is to work with memory, not write code.  If you\ndon't know what you're doing with the memory, you're guaranteed to be setting\nyourself (or others) up for failure. In this case, it means:    Harder-to-debug abstraction layers whenever the bindings don't work as you\n  expect . Writing Python bindings is already a level of abstraction that we're\n  accepting here as a necessary cost; the last thing needed is to add  even\n  more  cruft on top of that.     Absolute control over the memory and how it's managed . Rather than code all\n  sorts of machinery in order to perform simple tasks like cleaning up\n  allocations at module destruction time, or wasting time with  unique_ptr \n  and  shared_ptr  shennanigans, I find everything is much simpler when just\n  writing the bindings by hand.    pybind11, at least, does not account for the GIL by default unless you make\n  specific wrapper calls (e.g.  call_go  using the  call_guard policy). \n  Personally, after giving it a go, I see zero benefit to using it over writing \n  the bindings manually. Every framework has its own shennigans to work with\n  when using them, and I haven't really seen one that I considered worth the\n  cost of working with.    To that point,  not every project can afford to use a C++11-compliant\n  compiler . (Remember, as recently as Maya 2016, the official compiler version\n  was not even C++11 capable)!    The  historical results speak for themselves : The Maya OM1 bindings, which were\n  generated via SWIG, are far slower than the hand-written bindings in OM2\n  (which are also incidentally far easier to use and don't require the use of\n  other wrapper classes such as  MScriptUtil  to handle converting between\n  pointer and POD types). If you're going to eat of the cost of making bindings\n  between a scripting language and a compiled one, you might as well try to\n  minimize the overhead in the process. At scale, automatically-generated\n  bindings just don't work.     Tip  I encourage you to try the alternatives stated and decide for yourself which\napproach is easier at scale and works for your particular use case. Here,\nhowever, I will focus only on hand-writing the bindings and not on any\nunnecessary wrappers since I am focusing on simple examples.", 
            "title": "Why not use a wrapper for this?"
        }, 
        {
            "location": "/#how-is-this-going-to-work", 
            "text": "We're going to eschew the official Python distutils  for\nthis, and compile everything on our own. Before you start shouting \"That's\nun-Pythonic!\" from the top of your horse, bear with it: there are fairly good\nreasons for this, which I'll explain later.   We'll be making two types of Maya Python C++ Extensions: the first will be a\ntraditional Python C extension that makes use of the Maya libraries; the second,\nhowever, will be an actual Maya plugin that exposes the Python bindings\nautomatically once it's loaded in Maya. The nice thing about the second approach\nis that if you want to expose your bindings from a Maya plugin, you can do so\njust by loading the plugin itself without having add the  .pyd/.so  file onto\nthe  PYTHONPATH . However, this approach also comes with its own cons, which\nI will discuss during the implementation phase.", 
            "title": "How is this going to work?"
        }, 
        {
            "location": "/#requirements", 
            "text": "This tutorial will come from a  Windows-first approach . Whenever platform-specific\ninformation is appropriate, it will appear in the following form:   Crossing the platforms  Platform-specific information goes here.", 
            "title": "Requirements"
        }, 
        {
            "location": "/#what-you-will-need", 
            "text": "Maya 2018 or higher .     Python 2.7.xx (Python 3.x series is  not  a substitute!) .    A  C/C++ development environment  set up and ready to go. (If you want to see\n  what my Emacs setup looks like, it's\n  available  here .)    On Windows, you will need the corresponding  Visual Studio  version that\n  your version of Maya was compiled with. For Maya 2018, this is  Visual Studio\n  2015 .      Crossing the platforms  On Linux, you will need GCC 4.8.2 against the Linux kernel in CentOS 6.5.\nOn OSX, you will need Xcode 7.3.1 against the 10.11 SDK.    Spare time and an open mind.", 
            "title": "What you will need"
        }, 
        {
            "location": "/#what-you-should-know", 
            "text": "Basic knowledge of C/C++ . I will focus on including only the code that is\n  important; I expect you to be able to understand how to fill in the rest as\n  needed. At the very least, you should be able to compile a Maya plug-in and\n  run it using whatever toolchain you're familar with.    Basic knowledge of how Maya plugins work and how to write/build them . \n  The repository has sample build scripts designed to work on Windows and Linux.    Basic knowledge of Python . Obviously, you'll need to know basic Python\n  syntax and the various data types available, since we're going to be\n  marshaling them between them and C++.    In the next section, we'll go over a high-level overview of how a Python C/C++\nextension works.", 
            "title": "What you should know"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting started\n\n\nNow that we understand the goals of the project, let's dive a little bit into\nthe theory surrounding how a Python C extension works before writing any\nboilerplate. It'll help serve as a basis for guiding what we need to do first.\n\n\nWhat is a Python C Extension anyway?\n\n\nIf you have some competence with Python, you'll probably have noticed by now\nthat sometimes, certain Python modules aren't loaded in the traditional sense of\nhaving a \n.py\nfile along with a \n__init__.py\n file as well; there's usually\na single \n.pyd\n instead. If you've seen\nmy\n\nprevious tutorial\n,\nlet's expand on this: a \n.pyd\n file is essentially a DLL. It's the \nexact same\nformat\n. However, just like a Maya plugin (\n.mll\n on Windows) shares the exact\nsame format as a DLL does, a \n.pyd\n file follows specific conventions so that\nthe Python interpreter knows how to load it:\n\n\n\n\n\n\nThe entry point for module named \nfoo_bar.pyd\n will be automatically determined\n  to be \ninitfoo_bar\n. This is the convention that the Python interpreter uses\n  to search for a symbol so that it can dynamically load the library at run-time\n  when the statement \nimport foo_bar\n is parsed in the interpreter. We'll talk\n  about this more when we implement our own entry point in a bit.\n\n\n\n\n\n\nAs mentioned above, the \n.pyd\n file does not need to be linked with the main\n  program executable (Maya, in this case), since the Python\n  interpreter will be loading it dynamically at run-time. \n\n\n\n\n\n\nYou cannot rely on the standard method of declaring exports from a DLL, either\n  through symbol visiblity or specifying external linkage (i.e. \nextern\n  \"C\"\n). Python-specific exports must be declared through the use of special\n  functions, \nPy_InitModule\n and its variants. Again, we'll be talking about\n  this in a bit.\n\n\n\n\n\n\n\n\nCrossing the platforms\n\n\nOn Linux, \n.pyd\n files will instead be \n.so\n files, and (I believe, but\nI can't be bothered to boot up my Macbook to check) on OSX, these will be\n\n.dylib\n files.\n\n\n\n\nThe main takeaway here is that \npython modules are nothing special.\n They're\njust libraries, loaded at run-time dynamically, that follow specific conventions\nthe Python interpreter relies on to be able to function the way it does.\n\n\nOk, so we know that a \n.pyd\n is essentially just a DLL. Cool. So how does the\nPython interpreter know where to look for our module when we type \nimport foo_bar\n?\n\n\nLoading a Python module\n\n\n\n\nFast-forward\n\n\nIf you're already innately familiar with how Python searches for modules,\nyou can go ahead and skip to the next section. If not, I suggest you read\nthis part before continuing.\n\n\n\n\nThe search path for all modules globally available to Python happens in a couple\nof areas; one of those is on the path specified by the environment variable\n\nPYTHONPATH\n. If \nfoo_bar.pyd\n is available on that path, typing \nimport\nfoo_bar\n will cause the Python interpreter to attempt to load that \n.pyd\n\nfile, inspect it for a suitable entry point and initialize it if found. Once it\ndoes so, you'll be able to access the functions previously defined in its\n\nfunction table\n.\n\n\nBear in mind; if you have another conventional \nfoo_bar.py\nmodule also\navailable on the \nPYTHONPATH\n, ahead of the \n.pyd\n version, that module will\nbe used instead of the compiled version! It is therefore important to manage the\npaths on your \nPYTHONPATH\n, along with the namespaces of your modules.\n\n\n\"Hello, Maya\"\n\n\nBefore we write bindings to anything, we need \nsomething\n to actually bind\nto. Let's start with the timeless \nhello world\n.\n\n\n#include\n \nmaya/MGlobal.h\n\n\n\n\nvoid\n \nhelloWorldMaya\n()\n\n\n{\n\n    \nMGlobal\n::\ndisplayInfo\n(\nHello world from the Maya Python C extension!\n);\n\n\n    \nreturn\n;\n\n\n}\n\n\n\n\n\n\nYou should be able to tell what this does at a glance. Simple and\nstraightforward. However, instead of writing a bunch of boilerplate and an\n\nMPxCommand\n to fire off this function, we're going to skip all of that and  expose\nit directly to Python. Which means we get to write a whole different set\nof boilerplate instead!\n\n\n#include\n \nmaya_python_c_ext_py_hello_world.h\n\n\n#include\n \nmaya_python_c_ext_hello_world.h\n\n\n\n#include\n \nPython.h\n\n\n\n#include\n \nstdio.h\n\n\n\n\nstatic\n \nconst\n \nchar\n \nHELLO_WORLD_MAYA_DOCSTRING\n[]\n \n=\n \nSays hello world!\n;\n\n\n\nstatic\n \nPyObject\n \n*\npyHelloWorldMaya\n(\nPyObject\n \n*\nself\n,\n \nPyObject\n \n*\nargs\n);\n\n\n\nstatic\n \nPyObject\n \n*\npyHelloWorldMaya\n(\nPyObject\n \n*\nself\n,\n \nPyObject\n \n*\nargs\n)\n\n\n{\n\n    \nconst\n \nchar\n \n*\ninputString\n;\n\n    \nif\n \n(\n!\nPyArg_ParseTuple\n(\nargs\n,\n \ns\n,\n \ninputString\n))\n \n{\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nPyGILState_STATE\n \npyGILState\n \n=\n \nPyGILState_Ensure\n();\n\n\n    \nhelloWorldMaya\n();\n\n\n    \nPyObject\n \n*\nresult\n \n=\n \nPy_BuildValue\n(\ns\n,\n \ninputString\n);\n\n\n    \nPyGILState_Release\n(\npyGILState\n);\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\nOk, I typed a bunch of stuff up there that seems awfully scary. Let's break this\ndown line-by-line:\n\n\n#include\n \nPython.h\n\n\n\nstatic\n \nconst\n \nchar\n \nHELLO_WORLD_MAYA_DOCSTRING\n[]\n \n=\n \nSays hello world!\n;\n\n\n\n\n\n\nThis is fairly straightforward; I'm writing a Python C extension and I'm going\nto be using functionality from the Python libraries. I need the header.\n\n\nI also define a docstring that I would like my function to have. I know, \nfancy\n.\n\n\nstatic PyObject *pyHelloWorldMaya(PyObject *self, PyObject *args);\n\n\n\n\n\nWhat is a \nPyObject\n? If you look in the Python source code, you might lose\nyour sanity, so I'll summarize here: it's basically a typedef'ed type that\nPython uses to store information about a pointer to an object, so that it can\ntreat the \nPyObject\n \nitself as an object\n. Yes, this is Inception-mode.\n\n\nThe reason for this is that in a release build, the \nPyObject\n only contains\nthe reference count for the object (which is used for determining when the\nPython garbage collector is free to release the memory allocated to the object),\nalong with a pointer to the corresponding \ntype object\n.\n\n\nGarbage collection\n\n\nPython has an in-built garbage collector, which is another way of saying\nthat it attempts to manage the memory for you for the objects that you\nuse. There's actually two separate collectors, one being the \nreference\ncounting\n collector and the other \ngenerational\n collector, available in\nthe \ngc\n module, but we'll focus on the reference-counting one for\nnow.\n\n\nHow it works is that every object owned by Python (which is really just\na reference to an \nactual\n object with the \nactual\n data) has a simple counter\nthat tracks how many times a pointer to the object is copied or deleted and\nis incremented/decremented as necessary. Once the counter reaches \n0\n, the\nobject is free to be deallocated by the collector. It's a fairly simple\nmechanism; however, we need to make sure that we are aware of how it works\nsince if we forget to manage the memory correctly, we could end up having a\nmemory leak in our bindings or worse, a crash.\n\n\nMore information on this is available \nhere\n.\n\n\n\n\nThe \ngc\n module in Python\n\n\nSome of you might already be aware that Python comes with a \ngc\n module,\nwhich provides an interface to the \ngenerational garbage collector\n. While the\nconcept of two garbage collectors working together in unison sounds like a\nreceipe for disaster (and sometimes it is!), there's a method behind the\nmadness: the reference counting collector, due to being straightforward, is\nalso fast, but thus comes at a price: it cannot detect \nreference cycles\n.\n\n\nThat is to say, if you have one or more objects referencing each other, in\nterms of \ngraph theory\n, you have a \ncyclic dependency\n. A simple example in\ncode would be something like:\n\n\na.attribute1 = b;\nb.other_attribute = a\n\n\nIn such a case, the RC garbage collector would not reclaim the memory for\neither \na\n or \nb\n, even if they referred to nothing else. That's where\nthe second garbage collector steps in.\n\n\n\n\nSo what's the rest of the code doing, then?\n\n\nParsing the input arguments\n\n\nstatic\n \nPyObject\n \n*\npyHelloWorldMaya\n(\nPyObject\n \n*\nself\n,\n \nPyObject\n \n*\nargs\n)\n\n\n{\n\n    \nconst\n \nchar\n \n*\ninputString\n;\n\n    \nif\n \n(\n!\nPyArg_ParseTuple\n(\nargs\n,\n \ns\n,\n \ninputString\n))\n \n{\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nPyGILState_STATE\n \npyGILState\n \n=\n \nPyGILState_Ensure\n();\n\n\n    \nhelloWorldMaya\n();\n\n    \nMGlobal\n::\ndisplayInfo\n(\ninputString\n);\n\n\n    \nPyObject\n \n*\nresult\n \n=\n \nPy_BuildValue\n(\ns\n,\n \ninputString\n);\n\n\n    \nPyGILState_Release\n(\npyGILState\n);\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\nThe signature of the function is something that Python expects from a\n\nPyCFunction\n type. This is just something you'll have to accept as convention\nfor now; we'll see why this is enforced later when we register this function in\nthe \nfunction table\n. Basically our function must return a pointer to a\n\nPyObject\n, and take two pointers to \nPyObject\ns as well.\n\n\n\n\nThe \nPyCFunction\n signature\n\n\nWhat is this \nPyCFunction\n malarkey anyway? Well, if we look at the \nofficial \ndocumentation\n, \nwe see that it is basically the common type of function signature used for\n(almost) all the Python callable functions; the first two \nPyObject\n\npointer arguments have different semantics depending on what kind of flags\nare passed into the \nfunction table\n when the function is registered. For\nthe case above, since we used \nMETH_VARARGS\n as the flag describing how\nour function call should be constructed, the first pointer refers to the\nmodule object, and the second pointer refers to a tuple \nPyObject\n\nrepresenting all the arguments that were passed into the function from Python.\n\n\n\n\nThe first few lines make use of \nPyArg_ParseTuple\n to basically parse the\narguments given to the Python function. For example, if I called the function\n\nfoo_bar('oh noes')\n, \nPyArg_ParseTuple\n would, with the given arguments\nspecified, interpret the first argument as a string, and store that in the\n\ninputString\n pointer. If you look at\nthe \ndocumentation\n\nfor it, you'll realize that the format specifiers are similar to that of\n\nprintf\n in the standard library, but \nbe warned:\n there are subtle\ndifferences.\n\n\nThe next call we make is something you might not find in other \"HOW TO WRITE\nYOUR OWN PYTHON C EXTENSION\" tutorials, and that's because it's Maya-specific.\n\n\nThe Global Interpreter Lock (GIL)\n\n\nThis is a topic that comes up a lot, even for experienced TDs/programmers, so I\nthought I'd take my stab at explaining what is really at its core a fairly\nfundamental concept, if a bit complex.\n\n\nThe way I like to think about the GIL in Python is the following statement:\n\n\n\n\nThe Global Interpreter Lock in Python is a mutex.\n\n\n\n\nThat's it.\n\n\n\n\nMutex?\n\n\nFor those of us who aren't familiar with what a mutex is, it's shorthand\nfor \nmutual exclusion object\n. It is basically a mechanism (more often\nthan not implemented as a simple object with a unique ID) that allows a\nsingle thread within a running process to say, \"Hey, I need to access this\nmemory\". The program then requests (either by itself or from the OS, even) a\nhandle that can act as this program object. Once it is accquired by the\nthread, no other threads are allowed to access that memory (also known in\nparlance as a \ncritical section\n), until the mutex program object is\n\nreleased\n by the first thread owner.\n\n\n\n\nOk, so the \nactual\n implementation of the GIL goes a little beyond a simple\nmutex, but it essentially boils down to: the sole purpose of the GIL is to\nensure that Python objects (and the memory they point to) are protected from\nmulti-threaded access, making sure that Python bytecode can only be executed\nfrom a single thread at a single time. This is required in the CPython\nimplementation (which is what Maya's Python, and likely your system's Python\ninstallation as well is using) since the memory management implementation in\nCPython \nis not thread-safe\n.\n\n\nIn order to ensure that we follow the conventions required by CPython\nextensions, we must \naccquire the GIL\n before executing Python code\nourselves. This is \neven more important\n in Maya, because in Maya, \nthe main\nthread is not a Python thread\n. (In case that wasn't already obvious, otherwise\nthings would be much, much slower.)\n\n\nWhat we'll be doing is registering the GIL towards the main thread so that the\nPython interpreter can \"see\" it and execute our code. While normally in a Python\nC extension you probably wouldn't care about this, or would use\n\nPyEval_SaveThread\n and \nPyEval_RestoreThread\n instead, we make use of\n\nPyGILState_Ensure\n and \nPyGILState_Release\n to accquire and release the\nlock. Thus, we see these two calls surrounding the beginning and end of the\nrelevant critical section of our bindings that could end up calling Python code.\n\n\n\n\nWhy is \nmayapy\n special?\n\n\nJohn Calsbeek\n points out, correctly, that \nthis machination shouldn't be necessary; Maya should already have accquired\nthe GIL by then, since \nMaya should already have accquired it in order to\ncall into Python in the first place\n. So why do we have to explicitly make \nsure we accquire it again?\n\n\nWell, remember that we don't \nactually\n control the implementation of Maya\nAPI calls. If any of those calls happen to execute Python code (or MEL)\nwithout Maya knowing about it, Maya might crash, since you might end up\nexecuting Python code from a different thread than the Maya main thread. \nIf you can guarantee that all your binding did was purely native and did not \nmake any calls that execute Python bytecode, you don't need to re-accquire \nthe GIL. To be safe, though, we're going to do it in the examples here.\n\n\n\n\nReturning \nPyObject\n values\n\n\nWe see that the next unfamiliar statement is the line:\n\n\n    \nPyObject\n \n*\nresult\n \n=\n \nPy_BuildValue\n(\ns\n,\n \ninputString\n);\n\n\n\n\n\n\nIt's fairly straightfoward; this just uses the same format specifiers that\n\nPyArg_ParseTuple\n did to build a \nPyObject\n from the given C type. In this\ncase, we're building a Python string from our C string and returning that. Keep\nin mind that unlike in Python, we can only return one value from C functions, so\nkeeping the exact same connotations that you may have in your Python API might\nbe difficult if you don't follow this convention.\n\n\nSo, not that complicated, right? We'll begin writing the entry point in the next\nchapter, and then try to get a working \n.pyd\n file compiled right after.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "Now that we understand the goals of the project, let's dive a little bit into\nthe theory surrounding how a Python C extension works before writing any\nboilerplate. It'll help serve as a basis for guiding what we need to do first.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting_started/#what-is-a-python-c-extension-anyway", 
            "text": "If you have some competence with Python, you'll probably have noticed by now\nthat sometimes, certain Python modules aren't loaded in the traditional sense of\nhaving a  .py file along with a  __init__.py  file as well; there's usually\na single  .pyd  instead. If you've seen\nmy previous tutorial ,\nlet's expand on this: a  .pyd  file is essentially a DLL. It's the  exact same\nformat . However, just like a Maya plugin ( .mll  on Windows) shares the exact\nsame format as a DLL does, a  .pyd  file follows specific conventions so that\nthe Python interpreter knows how to load it:    The entry point for module named  foo_bar.pyd  will be automatically determined\n  to be  initfoo_bar . This is the convention that the Python interpreter uses\n  to search for a symbol so that it can dynamically load the library at run-time\n  when the statement  import foo_bar  is parsed in the interpreter. We'll talk\n  about this more when we implement our own entry point in a bit.    As mentioned above, the  .pyd  file does not need to be linked with the main\n  program executable (Maya, in this case), since the Python\n  interpreter will be loading it dynamically at run-time.     You cannot rely on the standard method of declaring exports from a DLL, either\n  through symbol visiblity or specifying external linkage (i.e.  extern\n  \"C\" ). Python-specific exports must be declared through the use of special\n  functions,  Py_InitModule  and its variants. Again, we'll be talking about\n  this in a bit.     Crossing the platforms  On Linux,  .pyd  files will instead be  .so  files, and (I believe, but\nI can't be bothered to boot up my Macbook to check) on OSX, these will be .dylib  files.   The main takeaway here is that  python modules are nothing special.  They're\njust libraries, loaded at run-time dynamically, that follow specific conventions\nthe Python interpreter relies on to be able to function the way it does.  Ok, so we know that a  .pyd  is essentially just a DLL. Cool. So how does the\nPython interpreter know where to look for our module when we type  import foo_bar ?", 
            "title": "What is a Python C Extension anyway?"
        }, 
        {
            "location": "/getting_started/#loading-a-python-module", 
            "text": "Fast-forward  If you're already innately familiar with how Python searches for modules,\nyou can go ahead and skip to the next section. If not, I suggest you read\nthis part before continuing.   The search path for all modules globally available to Python happens in a couple\nof areas; one of those is on the path specified by the environment variable PYTHONPATH . If  foo_bar.pyd  is available on that path, typing  import\nfoo_bar  will cause the Python interpreter to attempt to load that  .pyd \nfile, inspect it for a suitable entry point and initialize it if found. Once it\ndoes so, you'll be able to access the functions previously defined in its function table .  Bear in mind; if you have another conventional  foo_bar.py module also\navailable on the  PYTHONPATH , ahead of the  .pyd  version, that module will\nbe used instead of the compiled version! It is therefore important to manage the\npaths on your  PYTHONPATH , along with the namespaces of your modules.", 
            "title": "Loading a Python module"
        }, 
        {
            "location": "/getting_started/#hello-maya", 
            "text": "Before we write bindings to anything, we need  something  to actually bind\nto. Let's start with the timeless  hello world .  #include   maya/MGlobal.h  void   helloWorldMaya ()  { \n     MGlobal :: displayInfo ( Hello world from the Maya Python C extension! ); \n\n     return ;  }   You should be able to tell what this does at a glance. Simple and\nstraightforward. However, instead of writing a bunch of boilerplate and an MPxCommand  to fire off this function, we're going to skip all of that and  expose\nit directly to Python. Which means we get to write a whole different set\nof boilerplate instead!  #include   maya_python_c_ext_py_hello_world.h  #include   maya_python_c_ext_hello_world.h  #include   Python.h  #include   stdio.h  static   const   char   HELLO_WORLD_MAYA_DOCSTRING []   =   Says hello world! ;  static   PyObject   * pyHelloWorldMaya ( PyObject   * self ,   PyObject   * args );  static   PyObject   * pyHelloWorldMaya ( PyObject   * self ,   PyObject   * args )  { \n     const   char   * inputString ; \n     if   ( ! PyArg_ParseTuple ( args ,   s ,   inputString ))   { \n         return   NULL ; \n     } \n\n     PyGILState_STATE   pyGILState   =   PyGILState_Ensure (); \n\n     helloWorldMaya (); \n\n     PyObject   * result   =   Py_BuildValue ( s ,   inputString ); \n\n     PyGILState_Release ( pyGILState ); \n\n     return   result ;  }   Ok, I typed a bunch of stuff up there that seems awfully scary. Let's break this\ndown line-by-line:  #include   Python.h  static   const   char   HELLO_WORLD_MAYA_DOCSTRING []   =   Says hello world! ;   This is fairly straightforward; I'm writing a Python C extension and I'm going\nto be using functionality from the Python libraries. I need the header.  I also define a docstring that I would like my function to have. I know,  fancy .  static PyObject *pyHelloWorldMaya(PyObject *self, PyObject *args);  What is a  PyObject ? If you look in the Python source code, you might lose\nyour sanity, so I'll summarize here: it's basically a typedef'ed type that\nPython uses to store information about a pointer to an object, so that it can\ntreat the  PyObject   itself as an object . Yes, this is Inception-mode.  The reason for this is that in a release build, the  PyObject  only contains\nthe reference count for the object (which is used for determining when the\nPython garbage collector is free to release the memory allocated to the object),\nalong with a pointer to the corresponding  type object .", 
            "title": "\"Hello, Maya\""
        }, 
        {
            "location": "/getting_started/#garbage-collection", 
            "text": "Python has an in-built garbage collector, which is another way of saying\nthat it attempts to manage the memory for you for the objects that you\nuse. There's actually two separate collectors, one being the  reference\ncounting  collector and the other  generational  collector, available in\nthe  gc  module, but we'll focus on the reference-counting one for\nnow.  How it works is that every object owned by Python (which is really just\na reference to an  actual  object with the  actual  data) has a simple counter\nthat tracks how many times a pointer to the object is copied or deleted and\nis incremented/decremented as necessary. Once the counter reaches  0 , the\nobject is free to be deallocated by the collector. It's a fairly simple\nmechanism; however, we need to make sure that we are aware of how it works\nsince if we forget to manage the memory correctly, we could end up having a\nmemory leak in our bindings or worse, a crash.  More information on this is available  here .   The  gc  module in Python  Some of you might already be aware that Python comes with a  gc  module,\nwhich provides an interface to the  generational garbage collector . While the\nconcept of two garbage collectors working together in unison sounds like a\nreceipe for disaster (and sometimes it is!), there's a method behind the\nmadness: the reference counting collector, due to being straightforward, is\nalso fast, but thus comes at a price: it cannot detect  reference cycles .  That is to say, if you have one or more objects referencing each other, in\nterms of  graph theory , you have a  cyclic dependency . A simple example in\ncode would be something like:  a.attribute1 = b;\nb.other_attribute = a  In such a case, the RC garbage collector would not reclaim the memory for\neither  a  or  b , even if they referred to nothing else. That's where\nthe second garbage collector steps in.   So what's the rest of the code doing, then?", 
            "title": "Garbage collection"
        }, 
        {
            "location": "/getting_started/#parsing-the-input-arguments", 
            "text": "static   PyObject   * pyHelloWorldMaya ( PyObject   * self ,   PyObject   * args )  { \n     const   char   * inputString ; \n     if   ( ! PyArg_ParseTuple ( args ,   s ,   inputString ))   { \n         return   NULL ; \n     } \n\n     PyGILState_STATE   pyGILState   =   PyGILState_Ensure (); \n\n     helloWorldMaya (); \n     MGlobal :: displayInfo ( inputString ); \n\n     PyObject   * result   =   Py_BuildValue ( s ,   inputString ); \n\n     PyGILState_Release ( pyGILState ); \n\n     return   result ;  }   The signature of the function is something that Python expects from a PyCFunction  type. This is just something you'll have to accept as convention\nfor now; we'll see why this is enforced later when we register this function in\nthe  function table . Basically our function must return a pointer to a PyObject , and take two pointers to  PyObject s as well.   The  PyCFunction  signature  What is this  PyCFunction  malarkey anyway? Well, if we look at the  official \ndocumentation , \nwe see that it is basically the common type of function signature used for\n(almost) all the Python callable functions; the first two  PyObject \npointer arguments have different semantics depending on what kind of flags\nare passed into the  function table  when the function is registered. For\nthe case above, since we used  METH_VARARGS  as the flag describing how\nour function call should be constructed, the first pointer refers to the\nmodule object, and the second pointer refers to a tuple  PyObject \nrepresenting all the arguments that were passed into the function from Python.   The first few lines make use of  PyArg_ParseTuple  to basically parse the\narguments given to the Python function. For example, if I called the function foo_bar('oh noes') ,  PyArg_ParseTuple  would, with the given arguments\nspecified, interpret the first argument as a string, and store that in the inputString  pointer. If you look at\nthe  documentation \nfor it, you'll realize that the format specifiers are similar to that of printf  in the standard library, but  be warned:  there are subtle\ndifferences.  The next call we make is something you might not find in other \"HOW TO WRITE\nYOUR OWN PYTHON C EXTENSION\" tutorials, and that's because it's Maya-specific.", 
            "title": "Parsing the input arguments"
        }, 
        {
            "location": "/getting_started/#the-global-interpreter-lock-gil", 
            "text": "This is a topic that comes up a lot, even for experienced TDs/programmers, so I\nthought I'd take my stab at explaining what is really at its core a fairly\nfundamental concept, if a bit complex.  The way I like to think about the GIL in Python is the following statement:   The Global Interpreter Lock in Python is a mutex.   That's it.   Mutex?  For those of us who aren't familiar with what a mutex is, it's shorthand\nfor  mutual exclusion object . It is basically a mechanism (more often\nthan not implemented as a simple object with a unique ID) that allows a\nsingle thread within a running process to say, \"Hey, I need to access this\nmemory\". The program then requests (either by itself or from the OS, even) a\nhandle that can act as this program object. Once it is accquired by the\nthread, no other threads are allowed to access that memory (also known in\nparlance as a  critical section ), until the mutex program object is released  by the first thread owner.   Ok, so the  actual  implementation of the GIL goes a little beyond a simple\nmutex, but it essentially boils down to: the sole purpose of the GIL is to\nensure that Python objects (and the memory they point to) are protected from\nmulti-threaded access, making sure that Python bytecode can only be executed\nfrom a single thread at a single time. This is required in the CPython\nimplementation (which is what Maya's Python, and likely your system's Python\ninstallation as well is using) since the memory management implementation in\nCPython  is not thread-safe .  In order to ensure that we follow the conventions required by CPython\nextensions, we must  accquire the GIL  before executing Python code\nourselves. This is  even more important  in Maya, because in Maya,  the main\nthread is not a Python thread . (In case that wasn't already obvious, otherwise\nthings would be much, much slower.)  What we'll be doing is registering the GIL towards the main thread so that the\nPython interpreter can \"see\" it and execute our code. While normally in a Python\nC extension you probably wouldn't care about this, or would use PyEval_SaveThread  and  PyEval_RestoreThread  instead, we make use of PyGILState_Ensure  and  PyGILState_Release  to accquire and release the\nlock. Thus, we see these two calls surrounding the beginning and end of the\nrelevant critical section of our bindings that could end up calling Python code.   Why is  mayapy  special?  John Calsbeek  points out, correctly, that \nthis machination shouldn't be necessary; Maya should already have accquired\nthe GIL by then, since  Maya should already have accquired it in order to\ncall into Python in the first place . So why do we have to explicitly make \nsure we accquire it again?  Well, remember that we don't  actually  control the implementation of Maya\nAPI calls. If any of those calls happen to execute Python code (or MEL)\nwithout Maya knowing about it, Maya might crash, since you might end up\nexecuting Python code from a different thread than the Maya main thread. \nIf you can guarantee that all your binding did was purely native and did not \nmake any calls that execute Python bytecode, you don't need to re-accquire \nthe GIL. To be safe, though, we're going to do it in the examples here.", 
            "title": "The Global Interpreter Lock (GIL)"
        }, 
        {
            "location": "/getting_started/#returning-pyobject-values", 
            "text": "We see that the next unfamiliar statement is the line:       PyObject   * result   =   Py_BuildValue ( s ,   inputString );   It's fairly straightfoward; this just uses the same format specifiers that PyArg_ParseTuple  did to build a  PyObject  from the given C type. In this\ncase, we're building a Python string from our C string and returning that. Keep\nin mind that unlike in Python, we can only return one value from C functions, so\nkeeping the exact same connotations that you may have in your Python API might\nbe difficult if you don't follow this convention.  So, not that complicated, right? We'll begin writing the entry point in the next\nchapter, and then try to get a working  .pyd  file compiled right after.", 
            "title": "Returning PyObject values"
        }, 
        {
            "location": "/writing_the_python_standalone_module/", 
            "text": "Writing the Maya Python standalone module\n\n\nThe entry point\n\n\nThe entry point, as mentioned previously, must have a specific function\nsignature based off the desired module name.\n\n\nstatic\n \nchar\n \nMAYA_PYTHON_C_EXT_DOCSTRING\n[]\n \n=\n \nAn example Python C extension that makes use of Maya functionality.\n;\n\n\n\nstatic\n \nPyMethodDef\n \nmayaPythonCExtMethods\n[]\n \n=\n \n{\n\n    \n{\nhello_world_maya\n,\n \npyHelloWorldMaya\n,\n \nMETH_VARARGS\n,\n \nHELLO_WORLD_MAYA_DOCSTRING\n},\n\n    \n{\nNULL\n,\n \nNULL\n,\n \n0\n,\n \nNULL\n}\n\n\n};\n\n\n\nextern\n \nC\n \nPyMODINIT_FUNC\n \ninitmaya_python_c_ext\n()\n\n\n{\n\n    \nPyObject\n \n*\nmodule\n \n=\n \nPy_InitModule3\n(\nmaya_python_c_ext\n,\n\n                                      \nmayaPythonCExtMethods\n,\n\n                                      \nMAYA_PYTHON_C_EXT_DOCSTRING\n);\n\n    \nif\n \n(\nmodule\n \n==\n \nNULL\n)\n \n{\n\n        \nreturn\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAlright, let's break this down bit-by-bit again. The first line is fairly\nobvious; we're just defining a docstring for the module itself.\n\n\nThe second line, however, introduces a new \nPyMethodDef\n type: this is what\nwe're going to use for defining the \nfunction table\n available in our module to\nthe Python interpreter.\n\n\nListing the available methods\n\n\nPyMethodDef\n is essentially a structure with 4 fields: the name of the\nfunction desired (i.e. what we will actually type in the Python interpreter when\ncalling it), the callback to be executed, an enum indicating the type of\narguments that it accepts, and the docstring for the function itself that will\nbe displayed when someone calls \n.__doc__\n on the function object in the\nPython interpreter. We define \nmayaPythonCExtMethods\n as an array of these\nstructures, with a \nsentinel value\n of a structure with \nNULL\n fields to\nindicate the bounds of the array.\n\n\nWe then pass that to the call \nPy_InitModule3\n in our entry point\n\ninitmaya_python_c_ext\n, which will allow Python to register our module and\nregister the table, thus making the functions available for use in the\ninterpreter. We export the entry point with \nextern \"C\"\n so that the compiler\ndoesn't\n\nmangle\n the\nname of the symbol when it is compiled.\n\n\nOk, now we have all the code written. (Wasn't that fast?) We just need to\nactually build the \n.pyd\nnow so that we can use it.\n\n\nBuilding the extension\n\n\nThis is where I will stray a little from past tutorials, and even the official\nPython documentation: we will not be making use of \ndistutils\n or CMake or\nanything like that. We will write a \nbuild.bat\n. The \nbuild.bat\n will build\nthe code, no other nonsense involved. (And trust me, if you go down the\n\ndistutils\n route, there is a \nwhole lot\n of involvement.)\n\n\nThe \nbuild.bat\n script is provided in the\n\ncode for this repository\n. \nMost of it is fairly straightforward if you understand batch file syntax on Windows,\nso I'll only focus on the parts that concern this project.\n\n\n\n\nCrossing the platforms\n\n\nOn Linux, I provide a \nbuild.sh\n script, which is functionally similar to\nthe Windows \nbuild.bat\n. If you're only familiar with Bash syntax, you can\ntake a look at that instead.\n\n\n\n\nAfter the usual boilerplate of setting up the Visual Studio environment,\ncreating a build directory and all that jazz, we get to something interesting in\nthe script:\n\n\nset\n \nCommonCompilerFlags\n=\n%CommonCompilerFlags%\n /I\n%MayaRootDir%\n\\include\n /I \n%MayaRootDir%\n\\include\\python2.7\n\n\n\n\n\n\nNotice that we're not including the system Python headers directly. We also\ndon't link against the system Python either:\n\n\nset\n \nCommonLinkerFlags\n=\n%CommonLinkerFlags%\n \n%MayaLibraryDir%\n\\OpenMaya.lib\n \n%MayaLibraryDir%\n\\OpenMayaAnim.lib\n \n%MayaLibraryDir%\n\\OpenMayaFX.lib\n \n%MayaLibraryDir%\n\\OpenMayaRender.lib\n \n%MayaLibraryDir%\n\\OpenMayaUI.lib\n \n%MayaLibraryDir%\n\\Foundation.lib\n \n%MayaLibraryDir%\n\\IMFbase.lib\n \n%MayaLibraryDir%\n\\clew.lib\n \n%MayaLibraryDir%\n\\Image.lib\n \n%MayaLibraryDir%\n\\python27.lib\n\n\n\n\n\n\nWhy is this?\n\n\nWell, recall that for Maya specifically, there is a Python interpreter embedded\ndirectly in the application. It's also been modified slightly from the standard\nPython interpreter; in order to make sure that we don't encounter any funny\nissues down the line (read: crashes), we're going to link against Maya's version\ninstead. This does mean, however, that you should not attempt to use the module\nwe're building in a standard non-\nmayapy\n Python interpreter. (You probably\nwouldn't anyway, since the whole point is that we're making use of Maya-specific\nfunctionality in our module that wouldn't work in standard Python.)\n\n\nThere's one more thing we need to do:\n\n\nset\n \nPythonModuleExtension\n=\npyd\n\n\nset\n \nPythonModuleLinkerFlagsCommon\n=\n/export:initmaya_python_c_ext /out:\n%BuildDir%\n\\\n%ProjectName%\n.\n%PythonModuleExtension%\n\n\n\n\n\n\nRemember how we declared our entry point with C-linkage above? This is where we\nexport that symbol specifically. We need to do this on Windows, since symbols\nare stripped from the binary in release mode otherwise.\n\n\nThe rest of the build script is mostly boilerplate to actually compile and link\nthe module. If you have trouble understanding it, I suggest reading\nmy\n\nprevious tutorial\n which\ngoes over each section of the build script in greater detail.\n\n\nDo note: if you're going to just use my \nbuild.bat\n wholesale, make sure you\nedit the \nMayaRootDir\n variable to point to the root of your Maya\ninstallation. You should also make sure that the \ninclude\n folder from your\nMaya devkit is placed in there as well, or else edit the\n\nMayaIncludeDir\nvariable to point to it as needed.\n\n\n\n\nSo what's wrong with \ndistutils\n?\n\n\nOther than the fact that's it's yet another unnecessary abstraction and\nwould require me to run a seperate \npython setup.py build\n step outside of\nthe normal build script, it also attempts to call the wrong Visual Studio\ncompiler by default, since it's concerned with what the official Python\ndistribution was built against. Unfortunately, we're working with a custom\nbuild of Python in the case of Maya's Python interpreter, which basically\nmakes the entire \ndistutils\n build system an annoying nuinsance to work\naround. Besides, we have more control over what the compiler/linker are\nactually doing this way, without worrying about overriding any flags being\nset by default or other such distractions.\n\n\n\n\nRunning it in \nmayapy\n\n\nRun the following code in a \nmayapy\n interpreter:\n\n\nimport\n \nmaya.standalone\n\n\nmaya\n.\nstandalone\n.\ninitialize\n()\n\n\n\nimport\n \nsys\n\n\nsys\n.\npath\n.\nappend\n(\npath to the msbuild folder\n)\n\n\n\nfrom\n \nmaya_python_c_ext\n \nimport\n \n*\n\n\nhello_world_maya\n(\noh noes\n)\n\n\n\n\n\n\nYou should see:\n\n\nHello world from the Maya Python C extension!\noh noes\n\noh noes\n\n\n\n\n\n\nGreat! Now in the next chapter, we'll focus on implementing one of the things\npeople have been complaining about: a missing OM1 to OM2 binding.", 
            "title": "Writing the Module"
        }, 
        {
            "location": "/writing_the_python_standalone_module/#writing-the-maya-python-standalone-module", 
            "text": "", 
            "title": "Writing the Maya Python standalone module"
        }, 
        {
            "location": "/writing_the_python_standalone_module/#the-entry-point", 
            "text": "The entry point, as mentioned previously, must have a specific function\nsignature based off the desired module name.  static   char   MAYA_PYTHON_C_EXT_DOCSTRING []   =   An example Python C extension that makes use of Maya functionality. ;  static   PyMethodDef   mayaPythonCExtMethods []   =   { \n     { hello_world_maya ,   pyHelloWorldMaya ,   METH_VARARGS ,   HELLO_WORLD_MAYA_DOCSTRING }, \n     { NULL ,   NULL ,   0 ,   NULL }  };  extern   C   PyMODINIT_FUNC   initmaya_python_c_ext ()  { \n     PyObject   * module   =   Py_InitModule3 ( maya_python_c_ext , \n                                       mayaPythonCExtMethods , \n                                       MAYA_PYTHON_C_EXT_DOCSTRING ); \n     if   ( module   ==   NULL )   { \n         return ; \n     }  }   Alright, let's break this down bit-by-bit again. The first line is fairly\nobvious; we're just defining a docstring for the module itself.  The second line, however, introduces a new  PyMethodDef  type: this is what\nwe're going to use for defining the  function table  available in our module to\nthe Python interpreter.", 
            "title": "The entry point"
        }, 
        {
            "location": "/writing_the_python_standalone_module/#listing-the-available-methods", 
            "text": "PyMethodDef  is essentially a structure with 4 fields: the name of the\nfunction desired (i.e. what we will actually type in the Python interpreter when\ncalling it), the callback to be executed, an enum indicating the type of\narguments that it accepts, and the docstring for the function itself that will\nbe displayed when someone calls  .__doc__  on the function object in the\nPython interpreter. We define  mayaPythonCExtMethods  as an array of these\nstructures, with a  sentinel value  of a structure with  NULL  fields to\nindicate the bounds of the array.  We then pass that to the call  Py_InitModule3  in our entry point initmaya_python_c_ext , which will allow Python to register our module and\nregister the table, thus making the functions available for use in the\ninterpreter. We export the entry point with  extern \"C\"  so that the compiler\ndoesn't mangle  the\nname of the symbol when it is compiled.  Ok, now we have all the code written. (Wasn't that fast?) We just need to\nactually build the  .pyd now so that we can use it.", 
            "title": "Listing the available methods"
        }, 
        {
            "location": "/writing_the_python_standalone_module/#building-the-extension", 
            "text": "This is where I will stray a little from past tutorials, and even the official\nPython documentation: we will not be making use of  distutils  or CMake or\nanything like that. We will write a  build.bat . The  build.bat  will build\nthe code, no other nonsense involved. (And trust me, if you go down the distutils  route, there is a  whole lot  of involvement.)  The  build.bat  script is provided in the code for this repository . \nMost of it is fairly straightforward if you understand batch file syntax on Windows,\nso I'll only focus on the parts that concern this project.   Crossing the platforms  On Linux, I provide a  build.sh  script, which is functionally similar to\nthe Windows  build.bat . If you're only familiar with Bash syntax, you can\ntake a look at that instead.   After the usual boilerplate of setting up the Visual Studio environment,\ncreating a build directory and all that jazz, we get to something interesting in\nthe script:  set   CommonCompilerFlags = %CommonCompilerFlags%  /I %MayaRootDir% \\include  /I  %MayaRootDir% \\include\\python2.7   Notice that we're not including the system Python headers directly. We also\ndon't link against the system Python either:  set   CommonLinkerFlags = %CommonLinkerFlags%   %MayaLibraryDir% \\OpenMaya.lib   %MayaLibraryDir% \\OpenMayaAnim.lib   %MayaLibraryDir% \\OpenMayaFX.lib   %MayaLibraryDir% \\OpenMayaRender.lib   %MayaLibraryDir% \\OpenMayaUI.lib   %MayaLibraryDir% \\Foundation.lib   %MayaLibraryDir% \\IMFbase.lib   %MayaLibraryDir% \\clew.lib   %MayaLibraryDir% \\Image.lib   %MayaLibraryDir% \\python27.lib   Why is this?  Well, recall that for Maya specifically, there is a Python interpreter embedded\ndirectly in the application. It's also been modified slightly from the standard\nPython interpreter; in order to make sure that we don't encounter any funny\nissues down the line (read: crashes), we're going to link against Maya's version\ninstead. This does mean, however, that you should not attempt to use the module\nwe're building in a standard non- mayapy  Python interpreter. (You probably\nwouldn't anyway, since the whole point is that we're making use of Maya-specific\nfunctionality in our module that wouldn't work in standard Python.)  There's one more thing we need to do:  set   PythonModuleExtension = pyd set   PythonModuleLinkerFlagsCommon = /export:initmaya_python_c_ext /out: %BuildDir% \\ %ProjectName% . %PythonModuleExtension%   Remember how we declared our entry point with C-linkage above? This is where we\nexport that symbol specifically. We need to do this on Windows, since symbols\nare stripped from the binary in release mode otherwise.  The rest of the build script is mostly boilerplate to actually compile and link\nthe module. If you have trouble understanding it, I suggest reading\nmy previous tutorial  which\ngoes over each section of the build script in greater detail.  Do note: if you're going to just use my  build.bat  wholesale, make sure you\nedit the  MayaRootDir  variable to point to the root of your Maya\ninstallation. You should also make sure that the  include  folder from your\nMaya devkit is placed in there as well, or else edit the MayaIncludeDir variable to point to it as needed.   So what's wrong with  distutils ?  Other than the fact that's it's yet another unnecessary abstraction and\nwould require me to run a seperate  python setup.py build  step outside of\nthe normal build script, it also attempts to call the wrong Visual Studio\ncompiler by default, since it's concerned with what the official Python\ndistribution was built against. Unfortunately, we're working with a custom\nbuild of Python in the case of Maya's Python interpreter, which basically\nmakes the entire  distutils  build system an annoying nuinsance to work\naround. Besides, we have more control over what the compiler/linker are\nactually doing this way, without worrying about overriding any flags being\nset by default or other such distractions.", 
            "title": "Building the extension"
        }, 
        {
            "location": "/writing_the_python_standalone_module/#running-it-in-mayapy", 
            "text": "Run the following code in a  mayapy  interpreter:  import   maya.standalone  maya . standalone . initialize ()  import   sys  sys . path . append ( path to the msbuild folder )  from   maya_python_c_ext   import   *  hello_world_maya ( oh noes )   You should see:  Hello world from the Maya Python C extension!\noh noes oh noes   Great! Now in the next chapter, we'll focus on implementing one of the things\npeople have been complaining about: a missing OM1 to OM2 binding.", 
            "title": "Running it in mayapy"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/", 
            "text": "Exposing Python bindings directly in a Maya plugin\n\n\nIn the last major chapter, we successfully (hopefully) wrote a basic Maya Python\nC++ extension that utilized Maya functions to print the equivalent of \nhello world\n\nto \nstdout\n. We also saw how to parse basic arguments and pass that to our C function.\n\n\nNow, we're going to try and implement a simple binding that's been missing from\nOM2 for a while: \nMGlobal::selectByName\n.\n\n\nFrom the documentation:\n\n\nMStatus\n \nselectByName\n(\nconst\n \nMString\n \nname\n,\n \nMGlobal\n::\nListAdjustment\n \nlistAdjustment\n \n=\n \nkAddToList\n)\n\n\n\n\n\n\n\n\nPuts objects that match the give name on the active selection list.\n\n\n\n\nIn the interest of keeping things manageable, we're not going to implement the\nregex functionality that the original binding has (You can certainly do that\nyourself if you so wish), nor are we going to implement the other forms that\nthis call can take based on passing a different argument to\n\nlistAdjustment\n. (Also, simple convenience functions that are atomic in\nnature anyway are far easier to debug, not to mention faster due to the lack of\nbranching going on.)\n\n\nAdditionally, this time, we're going to implement things slightly differently;\ninstead of needing to compile a \n.pyd\n file, we're going to expose the\nbindings to the end-user directly when the \n.mll\n plugin is loaded. No messing\nwith the \nPYTHONPATH\n!\n\n\nThe new entry point\n\n\nTo do this, we'll need to change the plugin so that it actually \nis\n more like a\nconventional Maya plugin. Again, I go over how this machinery works in my\n\nprevious tutorial\n\nin great detail.\n\n\n#include\n \nmaya_python_c_ext_plugin_main.h\n\n\n#include\n \nmaya/MFnPlugin.h\n\n\n\nconst\n \nchar\n \n*\nkAUTHOR\n \n=\n \nSiew Yi Liang\n;\n\n\nconst\n \nchar\n \n*\nkVERSION\n \n=\n \n1.0.0\n;\n\n\nconst\n \nchar\n \n*\nkREQUIRED_API_VERSION\n \n=\n \nAny\n;\n\n\n\nPyObject\n \n*\nmodule\n \n=\n \nNULL\n;\n\n\n\n\nMStatus\n \ninitializePlugin\n(\nMObject\n \nobj\n)\n\n\n{\n\n    \nMFnPlugin\n \nplugin\n(\nobj\n,\n \nkAUTHOR\n,\n \nkVERSION\n,\n \nkREQUIRED_API_VERSION\n);\n\n    \nif\n \n(\n!\nPy_IsInitialized\n())\n \n{\n\n        \nPy_Initialize\n();\n\n    \n}\n\n\n    \nif\n \n(\nPy_IsInitialized\n())\n \n{\n\n        \nPyGILState_STATE\n \npyGILState\n \n=\n \nPyGILState_Ensure\n();\n\n\n        \nmodule\n \n=\n \nPy_InitModule3\n(\nmaya_python_c_ext\n,\n\n                                          \nmayaPythonCExtMethods\n,\n\n                                          \nMAYA_PYTHON_C_EXT_DOCSTRING\n);\n\n\n        \nMGlobal\n::\ndisplayInfo\n(\nRegistered Python bindings!\n);\n\n\n        \nif\n \n(\nmodule\n \n==\n \nNULL\n)\n \n{\n\n            \nreturn\n \nMStatus\n::\nkFailure\n;\n\n        \n}\n\n        \nPy_INCREF\n(\nmodule\n);\n\n\n        \nPyGILState_Release\n(\npyGILState\n);\n\n    \n}\n\n\n    \nreturn\n \nMStatus\n::\nkSuccess\n;\n\n\n}\n\n\n\n\nMStatus\n \nuninitializePlugin\n(\nMObject\n \nobj\n)\n\n\n{\n\n    \nMStatus\n \nstatus\n;\n\n\n    \nPy_DECREF\n(\nmodule\n);\n\n\n    \nreturn\n \nstatus\n;\n\n\n}\n\n\n\n\n\n\nLooks fairly similar to the code earlier, doesn't it? There are some slight\ndifferences, so let's go over them:\n\n\n    \nif\n \n(\n!\nPy_IsInitialized\n())\n \n{\n\n        \nPy_Initialize\n();\n\n    \n}\n\n\n\n\n\n\nHere, we check if the Python interpreter has been initialized yet, and if not,\nwe initialize it. This really shouldn't happen in practice, but it doesn't hurt\nto be safe.\n\n\nThe next state of affairs to take care of is the aforementioned GIL:\n\n\n        \nPy_INCREF\n(\nmodule\n);\n\n\n\n\n\n\nRemember how I talked about reference counting previously? We increment the\ncount here after we verify that the module has indeed been initialized\nappropriately.\n\n\nWe also implement the symmetric version of this in \nuninitializePlugin\n:\n\n\n    \nPy_DECREF\n(\nmodule\n);\n\n\n\n\n\n\nAt first glance, this seems fine; we're incrementing the reference count to the\nmodule in the plugin's entry point, and decrementing it in the exit point. By\nconventional wisdom, this should mean that our module will get cleaned up by the\nreference collector in Python when the Maya plugin is unloaded, thus saving on\nmemory usage and making everyone happy. For now, we'll assume that this works...\n\n\n\n\nForeshadowing\n\n\nForeshadowing is a literary device in which a writer gives an advance hint of\nwhat is to come later in the story. Foreshadowing often appears at the\nbeginning of a story, or a chapter, and it helps the reader develop\nexpectations about the upcoming events.\n\n\n\n\n(If you want to skip ahead to what I'm referring to, please\nread \nA possible problem\n.)\n\n\nImplementing \nselectByName\n\n\nAssuming that everything is going according to plan, let's go ahead and create\nthat missing OM2 binding we were talking about:\n\n\nenum\n \nMayaPythonCExtStatus\n\n\n{\n\n    \nUNKNOWN_FAILURE\n \n=\n \n-\n1\n,\n\n    \nNODE_DOES_NOT_EXIST\n \n=\n \n-\n2\n,\n\n    \nUNABLE_TO_GET_ACTIVE_SELECTION\n \n=\n \n-\n3\n,\n\n    \nUNABLE_TO_SET_ACTIVE_SELECTION\n \n=\n \n-\n4\n,\n\n    \nUNABLE_TO_MERGE_SELECTION_LISTS\n \n=\n \n-\n5\n,\n\n    \nSUCCESS\n \n=\n \n0\n\n\n};\n\n\n\n\nMayaPythonCExtStatus\n \naddToActiveSelectionList\n(\nconst\n \nchar\n \n*\nname\n)\n\n\n{\n\n    \nMStatus\n \nstat\n;\n\n\n    \nMSelectionList\n \nobjList\n;\n\n    \nstat\n \n=\n \nobjList\n.\nadd\n(\nname\n);\n\n    \nif\n \n(\n!\nstat\n)\n \n{\n\n        \nreturn\n \nMayaPythonCExtStatus\n::\nNODE_DOES_NOT_EXIST\n;\n\n    \n}\n\n\n    \nMSelectionList\n \nactiveSelList\n;\n\n    \nstat\n \n=\n \nMGlobal\n::\ngetActiveSelectionList\n(\nactiveSelList\n,\n \ntrue\n);\n\n    \nif\n \n(\n!\nstat\n)\n \n{\n\n        \nreturn\n \nMayaPythonCExtStatus\n::\nUNABLE_TO_GET_ACTIVE_SELECTION\n;\n\n    \n}\n\n\n    \nstat\n \n=\n \nactiveSelList\n.\nmerge\n(\nobjList\n);\n\n    \nif\n \n(\n!\nstat\n)\n \n{\n\n        \nreturn\n \nMayaPythonCExtStatus\n::\nUNABLE_TO_MERGE_SELECTION_LISTS\n;\n\n    \n}\n\n\n    \nstat\n \n=\n \nMGlobal\n::\nsetActiveSelectionList\n(\nactiveSelList\n);\n\n    \nif\n \n(\n!\nstat\n)\n \n{\n\n        \nreturn\n \nMayaPythonCExtStatus\n::\nUNABLE_TO_SET_ACTIVE_SELECTION\n;\n\n    \n}\n\n\n    \nreturn\n \nMayaPythonCExtStatus\n::\nSUCCESS\n;\n\n\n}\n\n\n\n\n\n\nAgain, this should be pretty simple to figure out what's going on. We check if\nthe object exists, and if it does, we add it to the actively-selected\nitems. But, for all intents and purposes, this is why you would use\n\nselectByName\n anyway, so it will fulfill our requirements for this particular \nexample.\n\n\nLet's go ahead and implement the Python binding for this:\n\n\nstatic\n \nPyObject\n \n*\npyAddToActiveSelectionList\n(\nPyObject\n \n*\nself\n,\n \nPyObject\n \n*\nargs\n)\n\n\n{\n\n    \nconst\n \nchar\n \n*\nnodeName\n;\n\n    \nif\n \n(\n!\nPyArg_ParseTuple\n(\nargs\n,\n \ns\n,\n \nnodeName\n))\n \n{\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nPyGILState_STATE\n \npyGILState\n \n=\n \nPyGILState_Ensure\n();\n\n\n    \nMayaPythonCExtStatus\n \nstat\n \n=\n \naddToActiveSelectionList\n(\nnodeName\n);\n\n    \nif\n \n(\nstat\n \n!=\n \nMayaPythonCExtStatus\n::\nSUCCESS\n)\n \n{\n\n        \nMGlobal\n::\ndisplayError\n(\nAn error occurred!\n);\n\n    \n}\n\n\n    \nPyObject\n \n*\nresult\n \n=\n \nPy_BuildValue\n(\nh\n,\n \nstat\n);\n\n\n    \nPyGILState_Release\n(\npyGILState\n);\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\nAs before, we see that the signature of the function follows that of a\n\nPyCFunction\n type, where two pointers to \nPyObject\ns are passed into the \nfunction. Again, we parse the first argument using \nPyArg_ParseTuple\n in order \nto extract the string that the caller passed into the Python function using the\n\ns\n format specifier. , we then ensure that the GIL is accquired once more\nbefore executing our code, call our C++ function, and then return the status\ncode (since it's an enum, we return a \nshort\n using the \nh\n format\nspecifier), while remembering to release the GIL when we're done with it.\n\n\nA possible problem\n\n\nNow, try this:\n\n\nimport\n \nmaya.cmds\n \nas\n \ncmds\n\n\n\ncmds\n.\nloadPlugin\n(\nmaya_python_c_ext\n)\n\n\nfrom\n \nmaya_python_c_ext\n \nimport\n \n*\n\n\nhello_world_maya\n(\nthis works\n)\n\n\n\ncmds\n.\nunloadPlugin\n(\nmaya_python_c_ext\n)\n\n\ncmds\n.\nloadPlugin\n(\nmaya_python_c_ext\n)\n\n\n\nhello_world_maya\n(\nhmm, I wonder what happens now...?\n)\n\n\n\n\n\n\nI'll wait.\n\n\n...\n\n\nBack yet? What did you see? Was it something similar to:\n\n\nStack trace:\n  python27.dll!PyEval_GetFuncDesc\n  python27.dll!PyEval_EvalFrameEx\n  python27.dll!PyEval_EvalCodeEx\n  python27.dll!PyRun_FileExFlags\n  python27.dll!PyRun_InteractiveOneFlags\n  python27.dll!PyRun_InteractiveLoopFlags\n  python27.dll!PyRun_AnyFileExFlags\n  python27.dll!Py_Main\n  KERNEL32.DLL!BaseThreadInitThunk\n  ntdll.dll!RtlUserThreadStart\n\nResult: untitled\nFatal Error. Attempting to save in C:/Users/sonictk/AppData/Local/Temp/sonictk.20180801.0110.ma\n\n\n\n\n\n...in case you skipped right here without trying it yourself (tsk, tsk), you\nprobably noticed what happened; you segfaulted the Python interpreter. Why is\nthis? Shouldn't the Python garbage collector have done its job and cleaned up\nafter us? Why are we still triggering a segmentation fault?\n\n\nIt turns out that, as usual, everything has to do with memory sooner or later,\nand this is one area that a memory-managed language such as Python is severely\ndeficient in.\n\n\nUnderstanding why the segfault happens\n\n\nIf you look closely at the script, you can see that we essentially perform the\nfollowing operations:\n\n\n\n\n\n\nLoad the DLL for our Maya plugin, which also initializes the Python bindings\n   to the embedded Python interpreter inside of Maya.\n\n\n\n\n\n\nWe import the module that contains our bindings, and all its members into the\n   global namespace for the Python interpreter.\n\n\n\n\n\n\nIf we recall, Python caches the modules that get loaded into memory. This is\n   done so that subsequent \nimport\n statements for the same module can just\n   re-use the already-loaded module object instead of re-importing it\n   again. Normally, this would be fine in a standard Python interpreter, where\n   \n.pyd\n files aren't expected to be unloaded at run-time once they've\n   already been loaded by the Python interpreter.\n\n\n\n\n\n\nHowever, when we call \ncmds.unloadPlugin\n to unload the \n.mll\n file at\n   run-time later, we have basically invalidated all memory to that module that\n   was loaded previously. \nEven though the Python interpreter is still holding a\n   reference to it!\n\n\n\n\n\n\nThus, when we call \nhello_world_maya\n the second time, we trigger\n   a \nsegmentation fault\n\n   since the function call basically is executing a jump instruction to a region\n   of memory that was already deallocated by the OS and is no longer valid for\n   use by the application.\n\n\n\n\n\n\nWhat can we do to avoid this?\n\n\nUnfortunately, not much that's non-intrusive; here's one solution:\n\n\nimport\n \nmaya.cmds\n \nas\n \ncmds\n\n\n\nARE_BINDINGS_VALID\n \n=\n \nFalse\n\n\n\n\ndef\n \nload_maya_plugin_and_validate_bindings\n(\npluginPath\n):\n\n    \ncmds\n.\nloadPlugin\n(\npluginPath\n)\n\n    \nimport\n \nmaya_python_c_ext\n\n\n    \nARE_BINDINGS_VALID\n \n=\n \nTrue\n\n\n    \nreturn\n \nmaya_python_c_ext\n\n\n\n\ndef\n \nunload_maya_plugin_and_invalidate_bindings\n(\nplugin\n):\n\n    \ncmds\n.\nunloadPlugin\n(\nplugin\n)\n\n\n    \nARE_BINDINGS_VALID\n \n=\n \nFalse\n\n\n\n\ndef\n \nvalidate_bindings\n():\n\n    \nreturn\n \nARE_BINDINGS_VALID\n\n\n\n\n\n\nAs you can see, we write very simple wrappers around loading/unloading our\nplugin. The wrapper functions just set a global variable called\n\nARE_BINDINGS_VALID\n that we use to check if, well, the bindings are valid.\n\n\nHow would these work in practice? Like so:\n\n\nimport\n \nsys\n\n\nimport\n \nos\n\n\nimport\n \nmaya.standalone\n\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \nmaya\n.\nstandalone\n.\ninitialize\n()\n\n    \nimport\n \nmaya.cmds\n \nas\n \ncmds\n\n\n    \nsys\n.\npath\n.\nappend\n(\nos\n.\npath\n.\njoin\n(\nos\n.\npath\n.\ndirname\n(\nos\n.\npath\n.\ndirname\n(\nos\n.\npath\n.\nabspath\n(\n__file__\n))),\n \npy\n))\n\n\n    \nimport\n \nvalidate\n\n\n    \npluginPath\n \n=\n \nos\n.\npath\n.\njoin\n(\nos\n.\npath\n.\ndirname\n(\nos\n.\npath\n.\ndirname\n(\nos\n.\npath\n.\nabspath\n(\n__file__\n))),\n \nmsbuild\n,\n \nmaya_python_c_ext.mll\n)\n\n    \nprint\n(\nloading plugin from {}\n.\nformat\n(\npluginPath\n))\n\n\n    \nmpce\n \n=\n \nvalidate\n.\nload_maya_plugin_and_validate_bindings\n(\npluginPath\n)\n\n\n    \nmpce\n.\nhello_world_maya\n(\nmy string\n)\n\n\n    \nvalidate\n.\nunload_maya_plugin_and_invalidate_bindings\n(\nmaya_python_c_ext\n)\n\n\n    \nif\n \nvalidate\n.\nvalidate_bindings\n():\n\n        \nmpce\n.\nhello_world_maya\n(\nmy string\n)\n\n    \nelse\n:\n\n        \nprint\n(\nThe bindings are no longer valid!\n)\n\n\n    \nmaya\n.\nstandalone\n.\nuninitialize\n()\n\n\n\n\n\n\nIt's not exactly what I would consider an ideal solution, but there rarely is\nsuch a thing. Alternatively, you could consider having an intermediate plugin\nhandle validating the bindings (although you would then need to guarantee that\nthis intermediate plugin itself was loaded at all times as well), but that's a\nlevel of complicatiion I don't want to get into right now.\n\n\n\n\nPython and unloading modules\n\n\nTo read more about why unloading Python modules has been such a contentious\nissue, you can \nlook at the discussion thread\n.\n\n\n\n\nWhen to use this method\n\n\nSo, with the aforementioned snafu, when would you want to make use of this\nalternative technique for exposing the bindings? It depends on the situation,\nbut for me personally, I think this is most useful when:\n\n\n\n\n\n\nYou do not need to guarantee availability of the bindings.\n\n\n\n\n\n\nThe functionality you're trying to expose is inherently tied to the rest of\n  the plugin. (i.e. debugging utilities for custom nodes)\n\n\n\n\n\n\nYou're willing to create extra indirection in order to defend against the\n  aforementioned problem, either by creating an intermediate plugin to act as a\n  \"guard\" layer that checks for validity of the module loaded before allowing\n  you to access the module, or just having Python wrapper functions that have\n  globals set to indicate the validity of the modules that have been loaded.\n\n\n\n\n\n\nPerhaps the use cases might be limited, but I think it's a good tool to keep in\nmind nonetheless.", 
            "title": "Exposing the Bindings Directly"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/#exposing-python-bindings-directly-in-a-maya-plugin", 
            "text": "In the last major chapter, we successfully (hopefully) wrote a basic Maya Python\nC++ extension that utilized Maya functions to print the equivalent of  hello world \nto  stdout . We also saw how to parse basic arguments and pass that to our C function.  Now, we're going to try and implement a simple binding that's been missing from\nOM2 for a while:  MGlobal::selectByName .  From the documentation:  MStatus   selectByName ( const   MString   name ,   MGlobal :: ListAdjustment   listAdjustment   =   kAddToList )    Puts objects that match the give name on the active selection list.   In the interest of keeping things manageable, we're not going to implement the\nregex functionality that the original binding has (You can certainly do that\nyourself if you so wish), nor are we going to implement the other forms that\nthis call can take based on passing a different argument to listAdjustment . (Also, simple convenience functions that are atomic in\nnature anyway are far easier to debug, not to mention faster due to the lack of\nbranching going on.)  Additionally, this time, we're going to implement things slightly differently;\ninstead of needing to compile a  .pyd  file, we're going to expose the\nbindings to the end-user directly when the  .mll  plugin is loaded. No messing\nwith the  PYTHONPATH !", 
            "title": "Exposing Python bindings directly in a Maya plugin"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/#the-new-entry-point", 
            "text": "To do this, we'll need to change the plugin so that it actually  is  more like a\nconventional Maya plugin. Again, I go over how this machinery works in my previous tutorial \nin great detail.  #include   maya_python_c_ext_plugin_main.h  #include   maya/MFnPlugin.h  const   char   * kAUTHOR   =   Siew Yi Liang ;  const   char   * kVERSION   =   1.0.0 ;  const   char   * kREQUIRED_API_VERSION   =   Any ;  PyObject   * module   =   NULL ;  MStatus   initializePlugin ( MObject   obj )  { \n     MFnPlugin   plugin ( obj ,   kAUTHOR ,   kVERSION ,   kREQUIRED_API_VERSION ); \n     if   ( ! Py_IsInitialized ())   { \n         Py_Initialize (); \n     } \n\n     if   ( Py_IsInitialized ())   { \n         PyGILState_STATE   pyGILState   =   PyGILState_Ensure (); \n\n         module   =   Py_InitModule3 ( maya_python_c_ext , \n                                           mayaPythonCExtMethods , \n                                           MAYA_PYTHON_C_EXT_DOCSTRING ); \n\n         MGlobal :: displayInfo ( Registered Python bindings! ); \n\n         if   ( module   ==   NULL )   { \n             return   MStatus :: kFailure ; \n         } \n         Py_INCREF ( module ); \n\n         PyGILState_Release ( pyGILState ); \n     } \n\n     return   MStatus :: kSuccess ;  }  MStatus   uninitializePlugin ( MObject   obj )  { \n     MStatus   status ; \n\n     Py_DECREF ( module ); \n\n     return   status ;  }   Looks fairly similar to the code earlier, doesn't it? There are some slight\ndifferences, so let's go over them:       if   ( ! Py_IsInitialized ())   { \n         Py_Initialize (); \n     }   Here, we check if the Python interpreter has been initialized yet, and if not,\nwe initialize it. This really shouldn't happen in practice, but it doesn't hurt\nto be safe.  The next state of affairs to take care of is the aforementioned GIL:           Py_INCREF ( module );   Remember how I talked about reference counting previously? We increment the\ncount here after we verify that the module has indeed been initialized\nappropriately.  We also implement the symmetric version of this in  uninitializePlugin :       Py_DECREF ( module );   At first glance, this seems fine; we're incrementing the reference count to the\nmodule in the plugin's entry point, and decrementing it in the exit point. By\nconventional wisdom, this should mean that our module will get cleaned up by the\nreference collector in Python when the Maya plugin is unloaded, thus saving on\nmemory usage and making everyone happy. For now, we'll assume that this works...   Foreshadowing  Foreshadowing is a literary device in which a writer gives an advance hint of\nwhat is to come later in the story. Foreshadowing often appears at the\nbeginning of a story, or a chapter, and it helps the reader develop\nexpectations about the upcoming events.   (If you want to skip ahead to what I'm referring to, please\nread  A possible problem .)", 
            "title": "The new entry point"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/#implementing-selectbyname", 
            "text": "Assuming that everything is going according to plan, let's go ahead and create\nthat missing OM2 binding we were talking about:  enum   MayaPythonCExtStatus  { \n     UNKNOWN_FAILURE   =   - 1 , \n     NODE_DOES_NOT_EXIST   =   - 2 , \n     UNABLE_TO_GET_ACTIVE_SELECTION   =   - 3 , \n     UNABLE_TO_SET_ACTIVE_SELECTION   =   - 4 , \n     UNABLE_TO_MERGE_SELECTION_LISTS   =   - 5 , \n     SUCCESS   =   0  };  MayaPythonCExtStatus   addToActiveSelectionList ( const   char   * name )  { \n     MStatus   stat ; \n\n     MSelectionList   objList ; \n     stat   =   objList . add ( name ); \n     if   ( ! stat )   { \n         return   MayaPythonCExtStatus :: NODE_DOES_NOT_EXIST ; \n     } \n\n     MSelectionList   activeSelList ; \n     stat   =   MGlobal :: getActiveSelectionList ( activeSelList ,   true ); \n     if   ( ! stat )   { \n         return   MayaPythonCExtStatus :: UNABLE_TO_GET_ACTIVE_SELECTION ; \n     } \n\n     stat   =   activeSelList . merge ( objList ); \n     if   ( ! stat )   { \n         return   MayaPythonCExtStatus :: UNABLE_TO_MERGE_SELECTION_LISTS ; \n     } \n\n     stat   =   MGlobal :: setActiveSelectionList ( activeSelList ); \n     if   ( ! stat )   { \n         return   MayaPythonCExtStatus :: UNABLE_TO_SET_ACTIVE_SELECTION ; \n     } \n\n     return   MayaPythonCExtStatus :: SUCCESS ;  }   Again, this should be pretty simple to figure out what's going on. We check if\nthe object exists, and if it does, we add it to the actively-selected\nitems. But, for all intents and purposes, this is why you would use selectByName  anyway, so it will fulfill our requirements for this particular \nexample.  Let's go ahead and implement the Python binding for this:  static   PyObject   * pyAddToActiveSelectionList ( PyObject   * self ,   PyObject   * args )  { \n     const   char   * nodeName ; \n     if   ( ! PyArg_ParseTuple ( args ,   s ,   nodeName ))   { \n         return   NULL ; \n     } \n\n     PyGILState_STATE   pyGILState   =   PyGILState_Ensure (); \n\n     MayaPythonCExtStatus   stat   =   addToActiveSelectionList ( nodeName ); \n     if   ( stat   !=   MayaPythonCExtStatus :: SUCCESS )   { \n         MGlobal :: displayError ( An error occurred! ); \n     } \n\n     PyObject   * result   =   Py_BuildValue ( h ,   stat ); \n\n     PyGILState_Release ( pyGILState ); \n\n     return   result ;  }   As before, we see that the signature of the function follows that of a PyCFunction  type, where two pointers to  PyObject s are passed into the \nfunction. Again, we parse the first argument using  PyArg_ParseTuple  in order \nto extract the string that the caller passed into the Python function using the s  format specifier. , we then ensure that the GIL is accquired once more\nbefore executing our code, call our C++ function, and then return the status\ncode (since it's an enum, we return a  short  using the  h  format\nspecifier), while remembering to release the GIL when we're done with it.", 
            "title": "Implementing selectByName"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/#a-possible-problem", 
            "text": "Now, try this:  import   maya.cmds   as   cmds  cmds . loadPlugin ( maya_python_c_ext )  from   maya_python_c_ext   import   *  hello_world_maya ( this works )  cmds . unloadPlugin ( maya_python_c_ext )  cmds . loadPlugin ( maya_python_c_ext )  hello_world_maya ( hmm, I wonder what happens now...? )   I'll wait.  ...  Back yet? What did you see? Was it something similar to:  Stack trace:\n  python27.dll!PyEval_GetFuncDesc\n  python27.dll!PyEval_EvalFrameEx\n  python27.dll!PyEval_EvalCodeEx\n  python27.dll!PyRun_FileExFlags\n  python27.dll!PyRun_InteractiveOneFlags\n  python27.dll!PyRun_InteractiveLoopFlags\n  python27.dll!PyRun_AnyFileExFlags\n  python27.dll!Py_Main\n  KERNEL32.DLL!BaseThreadInitThunk\n  ntdll.dll!RtlUserThreadStart\n\nResult: untitled\nFatal Error. Attempting to save in C:/Users/sonictk/AppData/Local/Temp/sonictk.20180801.0110.ma  ...in case you skipped right here without trying it yourself (tsk, tsk), you\nprobably noticed what happened; you segfaulted the Python interpreter. Why is\nthis? Shouldn't the Python garbage collector have done its job and cleaned up\nafter us? Why are we still triggering a segmentation fault?  It turns out that, as usual, everything has to do with memory sooner or later,\nand this is one area that a memory-managed language such as Python is severely\ndeficient in.", 
            "title": "A possible problem"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/#understanding-why-the-segfault-happens", 
            "text": "If you look closely at the script, you can see that we essentially perform the\nfollowing operations:    Load the DLL for our Maya plugin, which also initializes the Python bindings\n   to the embedded Python interpreter inside of Maya.    We import the module that contains our bindings, and all its members into the\n   global namespace for the Python interpreter.    If we recall, Python caches the modules that get loaded into memory. This is\n   done so that subsequent  import  statements for the same module can just\n   re-use the already-loaded module object instead of re-importing it\n   again. Normally, this would be fine in a standard Python interpreter, where\n    .pyd  files aren't expected to be unloaded at run-time once they've\n   already been loaded by the Python interpreter.    However, when we call  cmds.unloadPlugin  to unload the  .mll  file at\n   run-time later, we have basically invalidated all memory to that module that\n   was loaded previously.  Even though the Python interpreter is still holding a\n   reference to it!    Thus, when we call  hello_world_maya  the second time, we trigger\n   a  segmentation fault \n   since the function call basically is executing a jump instruction to a region\n   of memory that was already deallocated by the OS and is no longer valid for\n   use by the application.    What can we do to avoid this?  Unfortunately, not much that's non-intrusive; here's one solution:  import   maya.cmds   as   cmds  ARE_BINDINGS_VALID   =   False  def   load_maya_plugin_and_validate_bindings ( pluginPath ): \n     cmds . loadPlugin ( pluginPath ) \n     import   maya_python_c_ext \n\n     ARE_BINDINGS_VALID   =   True \n\n     return   maya_python_c_ext  def   unload_maya_plugin_and_invalidate_bindings ( plugin ): \n     cmds . unloadPlugin ( plugin ) \n\n     ARE_BINDINGS_VALID   =   False  def   validate_bindings (): \n     return   ARE_BINDINGS_VALID   As you can see, we write very simple wrappers around loading/unloading our\nplugin. The wrapper functions just set a global variable called ARE_BINDINGS_VALID  that we use to check if, well, the bindings are valid.  How would these work in practice? Like so:  import   sys  import   os  import   maya.standalone  if   __name__   ==   __main__ : \n     maya . standalone . initialize () \n     import   maya.cmds   as   cmds \n\n     sys . path . append ( os . path . join ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ))),   py )) \n\n     import   validate \n\n     pluginPath   =   os . path . join ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ))),   msbuild ,   maya_python_c_ext.mll ) \n     print ( loading plugin from {} . format ( pluginPath )) \n\n     mpce   =   validate . load_maya_plugin_and_validate_bindings ( pluginPath ) \n\n     mpce . hello_world_maya ( my string ) \n\n     validate . unload_maya_plugin_and_invalidate_bindings ( maya_python_c_ext ) \n\n     if   validate . validate_bindings (): \n         mpce . hello_world_maya ( my string ) \n     else : \n         print ( The bindings are no longer valid! ) \n\n     maya . standalone . uninitialize ()   It's not exactly what I would consider an ideal solution, but there rarely is\nsuch a thing. Alternatively, you could consider having an intermediate plugin\nhandle validating the bindings (although you would then need to guarantee that\nthis intermediate plugin itself was loaded at all times as well), but that's a\nlevel of complicatiion I don't want to get into right now.   Python and unloading modules  To read more about why unloading Python modules has been such a contentious\nissue, you can  look at the discussion thread .", 
            "title": "Understanding why the segfault happens"
        }, 
        {
            "location": "/exposing_the_bindings_in_maya_plugin/#when-to-use-this-method", 
            "text": "So, with the aforementioned snafu, when would you want to make use of this\nalternative technique for exposing the bindings? It depends on the situation,\nbut for me personally, I think this is most useful when:    You do not need to guarantee availability of the bindings.    The functionality you're trying to expose is inherently tied to the rest of\n  the plugin. (i.e. debugging utilities for custom nodes)    You're willing to create extra indirection in order to defend against the\n  aforementioned problem, either by creating an intermediate plugin to act as a\n  \"guard\" layer that checks for validity of the module loaded before allowing\n  you to access the module, or just having Python wrapper functions that have\n  globals set to indicate the validity of the modules that have been loaded.    Perhaps the use cases might be limited, but I think it's a good tool to keep in\nmind nonetheless.", 
            "title": "When to use this method"
        }, 
        {
            "location": "/credits/", 
            "text": "Resources\n\n\nCyrille Fauvel\n, \nwhose blog provided a trove of information on how to write this extension.\n\n\nOfficial Python documentation\n \nbasically contains a majority of the information I go over in this tutorial \n(excluding the Maya-specific areas) and is an invaluable resource for this subject.\nI would recommend perusing it if only for reference.\n\n\nSpecial Thanks\n\n\nRaffaele Fragapane\n\nAs usual, Raffaele is a great guy to bounce ideas off and it helps that he's pretty \ngood at pointing out holes in your assumptions. Also, if you work in Maya in any \ntechnical capacity whatsoever, watching his \nCult of Rig\n series is probably a \ngood idea.\n\n\nJohn Calsbeek\n\nFor pointing out a flaw in my reasoning regarding the GIL and pushing for a \nbetter explanation of the problem.\n\n\nAbout the author\n\n\nSiew Yi Liang\n: I wrote this overly-long wall of text and the example code\nhere. You can find more of my ramblings \nhere\n.", 
            "title": "Credits"
        }, 
        {
            "location": "/credits/#resources", 
            "text": "Cyrille Fauvel , \nwhose blog provided a trove of information on how to write this extension.  Official Python documentation  \nbasically contains a majority of the information I go over in this tutorial \n(excluding the Maya-specific areas) and is an invaluable resource for this subject.\nI would recommend perusing it if only for reference.", 
            "title": "Resources"
        }, 
        {
            "location": "/credits/#special-thanks", 
            "text": "Raffaele Fragapane \nAs usual, Raffaele is a great guy to bounce ideas off and it helps that he's pretty \ngood at pointing out holes in your assumptions. Also, if you work in Maya in any \ntechnical capacity whatsoever, watching his  Cult of Rig  series is probably a \ngood idea.  John Calsbeek \nFor pointing out a flaw in my reasoning regarding the GIL and pushing for a \nbetter explanation of the problem.", 
            "title": "Special Thanks"
        }, 
        {
            "location": "/credits/#about-the-author", 
            "text": "Siew Yi Liang : I wrote this overly-long wall of text and the example code\nhere. You can find more of my ramblings  here .", 
            "title": "About the author"
        }
    ]
}